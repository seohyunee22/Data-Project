# -*- coding: utf-8 -*-
"""ETL_script.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1k8qb8as70Rc4eItyQlrPGCnwVV3o1ZrK
"""

# !pip install pymysql
# !pip install uvicorn
# !pip install fastapi
# !pip install nest-asyncio pyngrok

"""### 1. 라이브러리 선언"""

import pandas as pd
from sqlalchemy import create_engine

# 데이터 처리 라이브러리
import pandas as pd
import numpy as np

# 데이터 연계 라이브러리
# from fastapi import FastAPI
from pydantic import BaseModel, validator
from datetime import datetime, timedelta

import os

import pandas as pd
import pymysql
from datetime import datetime

from dotenv import load_dotenv

"""### 2. 인터페이스 데이터 정의"""

# Pydantic 모델
class InDataset(BaseModel):
    inID: int
    inGet_time: datetime
    inAvg_glucosedata: int
    inAvg_heartrate: int
    inPeriod: object
    now_dttm: datetime

    # datetime 문자열을 datetime 객체로 변환하는 validator 추가
    @validator("inGet_time", pre=True)
    def parse_datetime(cls, v):
        if isinstance(v, str):
            return datetime.strptime(v, "%Y-%m-%d %H:%M:%S")  # datetime 형식으로 변환
        return v


"""### 3. DB - MYSQL"""

load_dotenv(dotenv_path="/home/ubuntu/prjETL/config.env")

# MySQL 연결 설정
connection = pymysql.connect(
    host=os.getenv("DB2_HOST"),
    user=os.getenv("DB2_USER"),
    password=os.getenv("DB2_PASSWORD"),
    database=os.getenv("DB2_NAME"),
    charset=os.getenv("DB2_CHARSET"),
    cursorclass=pymysql.cursors.DictCursor
)


### 데이터베이스 접속정보
user = os.getenv("DB1_USER")
password = os.getenv("DB1_PASSWORD")
dbip = os.getenv("DB1_HOST")
dbport = int(os.getenv("DB1_PORT"))
database = os.getenv("DB1_NAME")
dbConPath = f'mysql+pymysql://{user}:{password}@{dbip}:{dbport}/{database}'
myengine = create_engine(dbConPath)



"""### 4. 함수 정의"""
# 마지막 실행 날짜를 저장하는 파일 경로
# LAST_DATE_FILE= "/content/last_run_date.txt" # local 용
LAST_DATE_FILE = "/home/ubuntu/prjETL/last_run_date.txt"

# 1. 마지막 실행 날짜 get
def get_last_run_date():
    try:
        with open(LAST_DATE_FILE, 'r') as f:
            return datetime.strptime(f.read().strip(), '%Y-%m-%d').date()
    except FileNotFoundError:
        return None  # 파일이 없으면 초기값은 None

# 2. 마지막 실행 날짜 update
def update_last_run_date(date):
    # 디렉터리 존재 여부 확인 후 생성
    directory = os.path.dirname(LAST_DATE_FILE)
    if not os.path.exists(directory):
        os.makedirs(directory)
    with open(LAST_DATE_FILE, "w") as f:
        f.write(date.strftime("%Y-%m-%d"))

# 3. 데이터 insert
def insert_data_to_db(df, current_date):
    # 현재 날짜에 해당하는 데이터만 필터링
    current_data = df[df['date'] == current_date]
    if not current_data.empty:
        try:
            with connection.cursor() as cursor:
                for index, row in current_data.iterrows():
                    sql = """
                    INSERT INTO fmd_trend_analysis_combined_data
                    (inGet_time, inAvg_glucosedata, inAvg_heartrate, inPeriod, now_dttm)
                    VALUES (%s, %s, %s, %s, %s)
                    """
                    cursor.execute(sql, 
                                  (row['date'], 
                                   row['avg_glucosedata'], 
                                   row['avg_heartrate'], 
                                   row['period'], 
                                   datetime.now()))
                connection.commit()
                print(f"Data for {current_date} inserted successfully!")
        except Exception as e:
            print(f"Error inserting data: {e}")
            connection.rollback()
    else:
        print(f"No data available for {current_date}.")

# 4. Extract Data 
def extract_data() :    
    gcData = pd.read_sql_table("fmd_trend_analysis_blood_glucose", con=myengine)
    hrData = pd.read_sql_table("fmd_trend_analysis_heart_rate", con=myengine)
    
    return gcData, hrData

# 5. Transfrom (JOIN)
def transform_data(gc_df, hr_df) :

    for df, col in [(gc_df, 'get_time'), (hr_df, 'get_time')]:
        df[col] = pd.to_datetime(df[col])
        df['date'] = df[col].dt.date
        df['period'] = df[col].dt.hour.apply(lambda h: 'AM' if h < 12 else 'PM')

    gc_grouped = gc_df.groupby(['date', 'period']).agg(avg_glucosedata=('glucosedata', 'mean')).reset_index()
    hr_grouped = hr_df.groupby(['date', 'period']).agg(avg_heartrate=('heart_rate', 'mean')).reset_index()

    merged_df = pd.merge(gc_grouped, hr_grouped, on=['date', 'period'], how='inner')

    return merged_df.sort_values(by='date', ascending = True)
    

# 5. Main (LOAD)
def main():
    # 데이터 불러오기
    gcData, hrData = extract_data()
    df = transform_data(gcData, hrData)

    init_date = df['date'].min() 
    print(f"Initial Date: {init_date}")

    current_date = get_last_run_date() or init_date  
    print(f"Current Date: {current_date}")

    insert_data_to_db(df, current_date)

    current_date += timedelta(days=1)
    print(f"Next execution date: {current_date}")

    update_last_run_date(current_date)

if __name__ == "__main__":
    main()